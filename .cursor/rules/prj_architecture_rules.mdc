---
alwaysApply: true
---

# Project Architecture - This defines the current project architeture been used

## 📚 Knowledge

### Project Architecture: Clean Architecture + Next.js
The project follows **Clean Architecture** with Next.js App Router conventions:

```
src/
├── domain/           # Core business rules (independent)
├── application/      # Use cases and orchestration
├── infrastructure/   # External adapters (DB, AI, etc.)
├── presentation/     # Request/response handling (actions, handlers)
├── app/             # Next.js routing & pages (presentation layer)
└── lib/             # Shared utilities, config, logging
```

**Next.js Layout:**
- Follows Next.js default conventions (`src/app/`, `src/lib/`)
- `src/app/` contains Next.js routes, pages, and API routes
- `src/lib/` contains shared utilities, configuration, logging
- All business logic lives in domain/application/infrastructure layers

**Layer Dependency Flow (CRITICAL):**
```
Domain ← Application ← Infrastructure
Domain ← Application ← Presentation
Domain ← Application ← App (part of Presentation)
```

**How `app/` Fits Into Presentation Layer:**
- `src/app/` is the **Next.js routing layer** that belongs to the presentation layer
- Pages (`page.tsx`) call Server Actions from `src/presentation/actions/`
- API routes (`route.ts`) call handlers from `src/presentation/handlers/`
- `app/` should be **thin adapters** - only routing, no business logic
- Business logic stays in Application layer; `app/` orchestrates presentation

**Allowed:**
- ✅ Application uses Domain interfaces
- ✅ Infrastructure implements Domain interfaces
- ✅ Presentation (actions/handlers) uses Application use cases
- ✅ App (pages/routes) uses Presentation actions/handlers
- ✅ App pages can import from `src/lib/` for utilities

**Forbidden:**
- ❌ Domain must NOT import from any other layer
- ❌ Domain must NOT know about infrastructure or Next.js
- ❌ Application must NOT know about infrastructure details or Next.js
- ❌ Presentation must NOT access Infrastructure directly
- ❌ App pages must NOT call use cases directly (use actions/handlers)
- ❌ App pages must NOT contain business logic

### Layer Responsibilities

| Layer | Contains | Examples |
|-------|----------|----------|
| **Domain** | Business entities, interfaces | `User.ts`, `IUserRepository.ts` |
| **Application** | Use cases, DTOs | `CreateUserUseCase.ts`, `FlashcardDTO.ts` |
| **Infrastructure** | Repository implementations, AI services, DB | `UserRepository.ts`, `GeminiAIModel.ts` |
| **Presentation** | Server actions, handlers | `src/presentation/actions/actions.ts`, `src/presentation/handlers/UserHandler.ts` |
| **App** (Presentation) | Next.js routes, pages, layouts | `src/app/api/[resource]/route.ts`, `src/app/(pages)/page.tsx`, `src/app/layout.tsx` |
| **Lib** | Shared utilities, config, logging | `src/lib/config/`, `src/lib/logging/` |

### Next.js Conventions & Rules

**App Router Structure:**
- Use Next.js App Router conventions: `src/app/[route]/page.tsx` for pages
- Route groups: `src/app/(pages)/` for organization
- API routes: `src/app/api/[resource]/route.ts` (thin wrappers only)
- Layouts: `src/app/layout.tsx` for root layout

**App Folder Rules:**
- Pages are **thin** - only handle routing and UI rendering
- Pages call Server Actions (not use cases directly)
- API routes call handlers (not use cases directly)
- No business logic in `app/` folder - delegate to presentation layer
- Use Server Components by default, Client Components when needed (`'use client'`)

**Code Placement by Type**

| Type | Location | Example |
|------|----------|---------|
| Business Entity | `src/domain/entities/` | `User.ts` |
| Use Case | `src/application/use-cases/` | `CreateUserUseCase.ts` |
| DTO | `src/application/dtos/` | `CreateUserDTO.ts` |
| Repository Interface | `src/domain/interfaces/repositories/` | `IUserRepository.ts` |
| Repository Implementation | `src/infrastructure/adapters/database/` | `UserRepository.ts` |
| Service Interface | `src/domain/interfaces/services/` | `IAIModelService.ts` |
| Service Implementation | `src/infrastructure/adapters/` | `GeminiAIModel.ts` |
| Server Action | `src/presentation/actions/[domain]/` | `actions.ts` |
| API Handler | `src/presentation/handlers/[domain]/` | `UserHandler.ts` |
| Next.js Route | `src/app/api/[resource]/` | `route.ts` (3-5 lines only) |
| Page Component | `src/app/(pages)/[page]/` | `page.tsx` |

### Available Tools
- **GCP gcloud CLI**: Cloud Run deployments, GCP operations
- **Terraform**: Infrastructure as code
- **Docker CLI**: Containerization
- **GitHub CLI (gh)**: PR management, repository operations

### Server Actions vs API Routes Decision Matrix

| Scenario | Pattern | Location |
|----------|---------|----------|
| Form submission | ✅ Server Action | `src/presentation/actions/` |
| Data mutation | ✅ Server Action | `src/presentation/actions/` |
| Page data fetching | ✅ Server Action | `src/presentation/actions/` |
| User interactions | ✅ Server Action | `src/presentation/actions/` |
| External API | ✅ API Route | `src/app/api/` + handlers |
| Webhook | ✅ API Route | `src/app/api/` + handlers |
| Mobile backend | ✅ API Route | `src/app/api/` + handlers |
| Third-party integration | ✅ API Route | `src/app/api/` + handlers |

**Default:** Always start with Server Action unless external consumer requires API.

---

## 🎯 Rules

### Rule 1: Application Lifecycle Hooks
- Use hooks for startup and shutdown logic
- `appStartHook`: Initialize services, validate configuration
- `appEndHook`: Graceful shutdown and cleanup
- Always log key lifecycle events

---

## 🎯 Quick Reference Checklist
When creating new features:
1. ✅ Define Domain entity in `src/domain/entities/`
2. ✅ Define Repository interface in `src/domain/interfaces/repositories/`
3. ✅ Implement Repository in `src/infrastructure/adapters/database/`
4. ✅ Create Use Case in `src/application/use-cases/`
5. ✅ Create DTOs in `src/application/dtos/`
6. ✅ Create Server Action in `src/presentation/actions/[domain]/`
7. ✅ Add UUID comments to all code blocks
8. ✅ Log to development history
9. ✅ Write tests

---

## 🚨 Golden Rules
1. **Document Everything** – Each module must explain itself
2. **Keep Code Simple** – Readable and maintainable over clever
3. **Follow SRP** – One function, one responsibility
4. **Track All Changes** – Use UUID-based development history logging
5. **Validate Quality** – Linter and test checks required before completion
6. **Use Correct Structure** – Organized by Clean Architecture layers
7. **End Every Task with Documentation and Logging** – This is mandatory
